在c++多维数组其实就是数组的数组

当一个数组的元素依然是数组的时候，通常使用两个维度来定义它：一个维度表示数组本身的大小，另一个维度表示其元素(数组)的大小

```c++
int ia[3][4];
int arr[10][20][30]={0};
//大小为10的数组，每个元素都是大小为20的数组
//这些数组的元素是30个整形
//最后初始化为0
```

因此多维数组的定义方法是由内而外的

对于二维数组来说，第一个维度就是行，第二个维度称为列

### 多维数组的初始化

允许使用花括号括起来的一组初始值来初始化多维数组

```c++
	int ia[3][4]={
		{0,1,2,3},
		{4,5,6,7},
		{8,9,10,11}
	}

```

其中内部嵌套的花括号不是必须的，例如下面的初始化

```c++
	int ia[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
```

类似一维数组，在初始化多维数组时也并非所有元素是的值都必须包含在初始化列表中，如果仅仅想初始化每一行的第一个元素可以如下

```c++
	int ia[3][4] = {{0},{1},{2}};
```

其他未列出的元素执行默认值初始化，这些和一维数组一样，这时候如果省略内层花括号就不太一样

```c++
	int ia[3][4] = {0,1,3};
```

此时只初始化第一行的三个元素

### 多维数组的下标引用

如果下标运算符的数量和维度一样，则结果为对应元素，否则为内层数组/

```c++
	int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
	int (&row)[4] = ia[1];
	cout << row[0] << endl;
	ia[2][3] = arr[0][0][0];//都是元素
```

这里row时含有4个元素数组的引用，这里引用了ia的第二行，因此时正确的

```c++
	constexpr size_t rowCnt = 3 , colCnt=4;
	int ia[rowCnt][colCnt];
	for(size_t i=0 ; i!=rowCnt ; ++i){
		for(size_t j=0;j!=colCnt ;++j){
			ia[i][j]=i*colCnt+j;
		}
	}

```

### 使用范围for语句处理多维数组

```c++
size_t cnt = 0;
for(auto &row : ia){
    for(auto &col : row){
        col = cnt;
        cnt++;
    }
}
```

这里都是循环赋值，但是这里将挂历数组索引的任务交给了系统完成，因为要改变数组的值因此使用引用

在上面的例子中我们使用引用因为需要修改值,但是有一个深层次原因促使我们这么做

```c++
	for(const auto &row : ia){
		for(auto col : row){
			cout << col << endl;
		}
	}

```

这个循环并没有写操作，但是外层我们依然使用了引用，这是*为了避免数组被自动转化为指针！！*

```python
	for( auto row : ia){
		for(auto col : row){
			cout << col << endl;
		}
	}
```

遮掩时无法通过编译的，因为外层auto的结果时指针，这时候内层范围for不合法了！！！

### 指针和多维数组

当程序使用多维数组的名字的时候，也会自动加他变为首元组的指针！！！

因为多维数组的本质是数组的数组，数组名其实是指向内存数组的指针

```c++
	int ia[3][4];
	int (*p)[4]= ia;
	p = &ia[2];

```

p是一个指针，指向一个长度为4的int数组

> 注意，括号必不可少
>
> `int *p[4]`的结果是p是一个数组，数组的内容是int指针

c++11出现之后，我们可以通过auto和decltype避免在数组前加上一个指针类型了

```c++
	int ia[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
	int (*p)[4]= ia;
	p = &ia[2];
	for(auto p = ia ; p!=ia+3 ; ++p){
		for (auto q = *p ; q!=*p+4 ; ++q){
			cout << *q << endl;
		}
	}

```

当然使用标准库函数begin和end也可以实现同样的功能

```c++
	int ia[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
	int (*p)[4]= ia;
	p = &ia[2];
	for(auto p = begin(ia) ; p!=end(ia);++p){
		for(auto q = begin(*p) ;q!= end(*p) ; ++q){
			cout << *q << endl;
		}
	}

```

### 使用类型别名简化数组的指针

```c++
	using int_array = int[4];
	typedef int int_array[4];
	for(int_array *p = ia ; p!=ia+3 ; ++p){
		for (int *q = *p ; q!=*p+4 ; ++q){
			cout << *q << endl;
		}
	}

```

