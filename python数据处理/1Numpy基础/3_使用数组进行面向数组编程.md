# 使用数组进行面向数组编程

如果我们想要使用一个网格数据来计算`sqrt(x^2,y^2)`

此时我们使用`np.meshgrid`接收两个数组，并根据数组的又有(x,y)对生成一个二维数组

```python
import numpy as np
#%%
points = np.arange(-5,5,0.01)
#%%
xs , ys = np.meshgrid(points,points)
ys
-5.00,-5.00,-5.00,-5.00,-5.00,-5.00
-4.99,-4.99,-4.99,-4.99,-4.99,-4.99
-4.98,-4.98,-4.98,-4.98,-4.98,-4.98
-4.97,-4.97,-4.97,-4.97,-4.97,-4.97
-4.96,-4.96,-4.96,-4.96,-4.96,-4.96
-4.95,-4.95,-4.95,-4.95,-4.95,-4.95
-4.94,-4.94,-4.94,-4.94,-4.94,-4.94
-4.93,-4.93,-4.93,-4.93,-4.93,-4.93
```

> 关于meshgrid
>
> https://zhuanlan.zhihu.com/p/126266520
>
> 简单来说,xs就是x的坐标值,ys就是y的坐标值，将两者结合就是所有点的坐标值

此时我们就可以使用同样的表达式来进行运算

```python
z  = np.sqrt(xs**2+ys**2)
7.071068,7.064000,7.056940,7.049887,7.042840,7.035801
7.064000,7.056926,7.049858,7.042798,7.035744,7.028698
7.056940,7.049858,7.042784,7.035716,7.028656,7.021602
7.049887,7.042798,7.035716,7.028641,7.021574,7.014514
7.042840,7.035744,7.028656,7.021574,7.014499,7.007432
7.035801,7.028698,7.021602,7.014514,7.007432,7.000357
7.028769,7.021659,7.014556,7.007460,7.000371,6.993290
7.021745,7.014628,7.007517,7.000414,6.993318,6.986229
7.014727,7.007603,7.000486,6.993375,6.986272,6.979176
```

此时z就是通过运算后该点应该有的值

我们可以使用matplotlib进行可视化

```python
plt.imshow(z,cmap=plt.cm.gray);plt.colorbar()
```

## 1. 将条件逻辑作为数组操作

`np.where`是三元表达式的向量化版本假设我们有布尔值数组

```python
xarr = np.array([1.1,1.2,1.3,1.4,1.5])
yarr = np.array([2.1,2.2,2.3,2.4,2.5])
cond = np.array([True,False,True,True,False])
```

只有为True的时候我们去除xarr的值，否则去除yarr的值

我们可以使用推导来完成

```python
result = [(x if c else y) for x,y,c in zip(xarr,yarr,cond)]
result
[1.1, 2.2, 1.3, 1.4, 2.5]
```

如果是多维数组的话，这样就失效了

```python
result = np.where(cond , xarr, yarr)
result
1.1
2.2
1.3
1.4
2.5
```

`np.where`后两个参数可以不是数组可以是标量，

如果我们想将一个数组的正值变为2，负值变为-2则可以

```python
arr = np.random.randn(4,4)

arr
-0.901845,1.239465,0.732856,-0.187424
-1.337093,-0.355605,-0.335415,0.421919
0.518010,0.218419,0.572388,0.654436
-0.104570,1.685594,1.261965,-0.168007

np.where(arr>0,2,-2)
-2,2,2,-2
-2,-2,-2,2
2,2,2,2
-2,2,2,-2
```

同样我们可以将数组和标量结合来实现其他操作

## 2. 数学和统计方法

 聚合函数(缩减函数)，我们既可以直接调用数组的实例方法

```python
arr = np.random.randn(5,4)
arr.mean()
0.38502383047139366
```

这些函数可以接收可选参数`exis`用来计算定轴上的统计值，形成下降一个维度的数组

```python
arr.mean(axis=1)
arr.sum(axis=0)
```

第一条语句表示计算列轴上的平均值，第二条则是计算行轴方向上的和

> 由此可以看出：（划重点）通过不同的axis，numpy会沿着不同的方向进行操作：如果不设置，那么对所有的元素操作；如果axis=0，则沿着纵轴进行操作；axis=1，则沿着横轴进行操作。但这只是简单的二位数组，如果是多维的呢？可以总结为一句话：设axis=i，则numpy沿着第i个下标变化的方向进行操作。例如刚刚的例子，可以将表示为：
>
> data =[[a00, a01],
>        [a10, a11]]
> 所以axis=0时，沿着第0个下标变化的方向进行操作，也就是a00->a10, a01->a11，也就是纵坐标的方向，axis=1时也类似。

其他方法例如`cumsum`和`cumprod`并不会聚合，他们会产生一个中间结果

```python
arr = np.array([1,2,3,4,5,6,7])
arr.cumsum()
1
3
6
10
15
21
28
```

在多维数组中，想cumsum这种累积函数返回相同长度的数组，但是可以通过指定轴向上根据较低维度的切片进行部分聚合

```python
arr = np.array([[0,1,2],[3,4,5],[6,7,8]])
arr
0,1,2
3,4,5
6,7,8

arr.cumsum(axis=0)
0,1,2
3,5,7
9,12,15

arr.cumsum(axis=1)
0,1,3
3,7,12
6,13,21
```

### 基础数组统计方法

```python
sum
mean
std,var #标准差和方差，可以自由选择维度
min,max
argmin,argmax #最大值和最小值的位置
cumsum
cumpord #从1开始元素累积积
```

## 3. 布尔数组的方法

布尔数组会被强制为1(True),0(False)，因此sum通常可以用于计算布尔值数组中True的个数

```python
arr = np.random.randn(100)
(arr>0).sum()
47
```

对于布尔值数组有两个很有用的方法，any和all

- any检查数组是否至少有一个True
- all检查是否每一个值都是True

```python
bools = np.array([False,False,True,False])
bools.any()
True
bools.all()
False
```

这两个方法同样适用于非布尔数组,非0会作为True来处理

### 排序

数组可以使用`sort`进行位置排序

```python
arr = np.random.randn(6)
arr
0.522299
-0.041054
0.720154
0.890576
-1.206393
1.563530

arr.sort()
arr
-1.206393
-0.041054
0.522299
0.720154
0.890576
1.563530
```

在多维数组中我们可以使用axis进行在特定轴上进行排序

```python
arr = np.random.randn(5,4)
arr
-0.084802,1.231068,0.495750,0.765471
0.555730,-0.544443,1.227591,-0.465789
-0.207929,0.698085,0.338851,-0.107899
-0.644558,-0.964165,-0.641605,0.432523
0.842621,0.415231,-1.499672,-0.732843

arr.sort(1)
arr
-0.084802,0.495750,0.765471,1.231068
-0.544443,-0.465789,0.555730,1.227591
-0.207929,-0.107899,0.338851,0.698085
-0.964165,-0.644558,-0.641605,0.432523
-1.499672,-0.732843,0.415231,0.842621
```

顶层的`np.sort`函数返回的是已经排序好的数组，而不是对原数组进行排序

此例子：是计算一个数组的分位数，并选出分位数所对应的值

```python
large_arr = np.random.randn(100)
large_arr
large_arr.sort()
large_arr[int(0.05*len(large_arr))]
-1.528093757390354
```

## 4. 唯一值与其他集合逻辑

numpy包含针对一维数组的基础操作集合，常用的是`np.unique`返回数组中唯一值排序后形成的数组

```python
names = np.array(['J1',"Bob","Bob","J3","Joe","Joe"])
np.unique(names)
Bob
J1
J3
Joe
```

整型数组同理

*****

`np.in1d`可以检查一个数组是否在另一个数组中，返回布尔数组

```python
values= np.array([6,0,0,3,2,5,6])
np.in1d(values,[2,3,6])
True
False
False
True
True
False
True
```

### 数组操作集合

```python
unique(x)
intersect1d(x,y)#计算x和y的交集，并排序
union1d(x,y)#计算x和y的并集，并排序
in1d(x,y)
setdiff1d(x,y)#差集，在x但是不再y中的x元素
setxor1d(x,y)#异或集，在x或y中，但是不属于x和y交集的元素
```

