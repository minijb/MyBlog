# ndarray

numpy的核心特征即使N-维数组对象，ndarray

**简单使用**

```python
import numpy as np
#%%
data = np.random.randn(2,3)
data
```

在ndarray中所有的数据类型都是相同的，具有通用属性：shape和dtype

```python
data.shape#(2, 3)
data.dtype#dtype('float64')
```

## 1. 生成ndarray

生成ndarray最简单的方式就是使用array函数，此函数接收任意的序列型对象，生成包含传递数据的numpy数组

```python
In [1]: import numpy as np

In [2]: data1 = [6,7,8.5,0,1]

In [3]: arr1 = np.array(data1)

In [4]: arr1
Out[4]: array([6. , 7. , 8.5, 0. , 1. ])

```

同样可以使用嵌套数组直接转变为多为数组

```python
In [5]: data2 = [[1,2,3,4],[5,6,7,8]]

In [6]: arr2 = np.array(data2)

In [7]: arr2
Out[7]: 
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])

```

除非显示的指定类型否则array函数会自动推断数据类型

```python
In [8]: arr1.dtype
Out[8]: dtype('float64')

In [9]: arr2.dtype
Out[9]: dtype('int64')

```

除了array，`zeros `可以创建全0的数组，`ones`可以创建全1的数组,`empty`可以创建没有初始化数值的数组，想要创建高维数组，需要为shape传递一个元组

```python
In [10]: np.zeros(10)
Out[10]: array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])

In [11]: np.ones((2,3))
Out[11]: 
array([[1., 1., 1.],
       [1., 1., 1.]])

In [12]: np.empty((2,3,2))
Out[12]: 
array([[[4.64348107e-310, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000]],

       [[0.00000000e+000, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000],
        [0.00000000e+000, 0.00000000e+000]]])

```

`arange`函数是range的升级版可以自动创建一个ndarray

```python
In [13]: np.arange(10)
Out[13]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

> np创建的数组的一般dtype都是浮点类型，`float64`

### 其他数组生成函数

```python
array
asarray #将输入转化为nsarray，如果输入时ndarray则不再复制
arange
ones
ones_like #根据所给数据类型生成形状一样的全1数组
zeros
zeros_like
empty
empty_like
full #根据给定形状和数据类型乘车指定数值的数组
full_like
eye,identity #生成一个N*N的矩阵，主对角为1，其余为0
```

## 2. dtype数据类型

```c++
In [2]: arr1=np.array([1,2,3],dtype=np.float64)

In [3]: arr2=np.array([1,2,3],dtype=np.int32)

In [4]: arr1.dtype
Out[4]: dtype('float64')

In [5]: arr2.dtype
Out[5]: dtype('int32')
```

我们可以通过`astype`方法来修改类型

```python
In [6]: arr1.astype(np.int32)
Out[6]: array([1, 2, 3], dtype=int32)
```

如果我们一个字符串数组，我们也可以通过dtype来将他转换为对应类型

```python
In [8]: nstrings = np.array(['1.2','1.11','12.2'],dtype=np.string_)
In [12]: nstrings.astype(np.float64)
Out[12]: array([ 1.2 ,  1.11, 12.2 ])
```

## 3. Numpy数组算术

```python
In [14]: arr = np.array([[1.,2.,3.],[4.,5.,6.]])

In [15]: arr*arr
Out[15]: 
array([[ 1.,  4.,  9.],
       [16., 25., 36.]])

In [16]: arr-arr
Out[16]: 
array([[0., 0., 0.],
       [0., 0., 0.]])
```

同样也可以带标量

```python
In [17]: 1/arr
Out[17]: 
array([[1.        , 0.5       , 0.33333333],
       [0.25      , 0.2       , 0.16666667]])

In [18]: arr**0.5
Out[18]: 
array([[1.        , 1.41421356, 1.73205081],
       [2.        , 2.23606798, 2.44948974]])

```

相同尺寸的数组之间的比较会产生一个**布尔数组**

```python
In [19]: arr2 = np.array([[0.,4.,1.],[7.,2.,12.]])

In [20]: arr2 > arr
Out[20]: 
array([[False,  True, False],
       [ True, False,  True]])

```

## 4. 基础索引和切片

以为数组的索引和切片，和python中的相似。唯一不同是切片可以赋值，并直接映射到原本数组上(因为切片其实就是原数组的视图)

```python
In [21]: arr =np.arange(10)

In [22]: arr[4:7]=12

In [23]: arr
Out[23]: array([ 0,  1,  2,  3, 12, 12, 12,  7,  8,  9]) 
```

```python
In [29]: arr_s = arr[4:7]

In [30]: arr_s[1] = 13

In [31]: arr
Out[31]: array([ 0,  1,  2,  3, 12, 13, 12,  7,  8,  9])
```

因为是视图，所以这里修改arr_s的值也就映射到原数组上

如果使用`[:]`直接引用整个数组

> 如果我们需要一份拷贝而不是视图的话：可以使用`arr.copy()`



如果是二维数组的话单个索引就是一个数组，这时候我们由两种方式来选择当个元素

```python
In [32]: arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])

In [33]: arr2d[0][1]
Out[33]: 2

In [34]: arr2d[0,1]
Out[34]: 2
```

![Snipaste_2022-08-26_21-08-05.png](https://s2.loli.net/2022/08/27/H2SKZrLnv1ER8Jc.png)

0轴为行，1轴为列

在多维数组中，你可以省略后继索引值，返回的对象将是一个降低一维的数组。因此在一个`2*2*3`的数组中

```python
arr3d = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])
arr3d[0]=42#这就是一个2维数组
arr3d
array([[[42, 42, 42],
        [42, 42, 42]],

       [[ 7,  8,  9],
        [10, 11, 12]]])
arr3d[1,0]#一个一维数组
```

### 数组的切片索引

索引可以多组索引

```python
arr = np.arange(10)
arr
Out[4]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr2d = np.array([[1,2,3],[4,5,6],[7,8,9]])

arr2d
Out[6]: 
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

arr2d[:2]
Out[7]: 
array([[1, 2, 3],
       [4, 5, 6]])

arr2d[:2,1:]
Out[8]: 
array([[2, 3],
       [5, 6]])

```

如果切片和索引一起使用就会降低维度

```python
arr2d[0,1:3]
Out[10]: array([2, 3])
```

此时对切片表达式赋值时，整个切片都会重新赋值

注意：索引会降低维度，索引不会

```python
arr2d[0,1:3].shape
Out[11]: (2,)

arr2d[0:1,1:3].shape
Out[12]: (1, 2)
```

## 4. 布尔索引

```py
In [3]: names = np.array(['Bob',"J1","J2",'J3','J4','J5','J6'])

In [4]: data = np.random.randn(7,4)

In [5]: data
Out[5]: 
array([[-0.18325819, -0.66660485,  2.645787  ,  0.18188231],
       [ 0.62831675, -0.35374143, -0.71441057,  1.29473949],
       [ 0.70806562, -0.85558182,  1.57581798,  0.41072139],
       [-1.15387603,  0.65960428,  0.91796562,  0.61214259],
       [ 1.98878445,  0.00424501,  1.6154884 , -0.29993039],
       [-1.15881282,  0.64665924,  0.85159943, -0.25057066],
       [ 0.58831105, -0.90918661, -0.55823388,  0.94581277]])
```

假设每行对应一个名字，我们需要选出Bob对应的行，我们可以通过布尔数组快速选择对应的行

```python
In [8]: names == "Bob"
Out[8]: array([ True, False, False,  True, False, False, False])

In [9]: data[names=="Bob"]
Out[9]: 
array([[-0.18325819, -0.66660485,  2.645787  ,  0.18188231],
       [-1.15387603,  0.65960428,  0.91796562,  0.61214259]])
```

布尔数组的长度必须和数组轴索引长度一致。

> 在布尔子数组的长度不确定的时候，布尔值选择数据的方法不会报错，因此要小心

我们同时引入切片和索引操作

```python
In [10]: data[names=="Bob",2:]
Out[10]: 
array([[2.645787  , 0.18188231],
       [0.91796562, 0.61214259]])
In [11]: data[names=="Bob",3]
Out[11]: array([0.18188231, 0.61214259])
```

可以看到布尔取值作用在行，索引和切片作用在列上

同理我们也可以选择不是Bob的选项

```python
In [13]: names != "Bob"
Out[13]: array([False,  True,  True, False,  True,  True,  True])
In [15]: data[~(names=="Bob")]
Out[15]: 
array([[ 0.62831675, -0.35374143, -0.71441057,  1.29473949],
       [ 0.70806562, -0.85558182,  1.57581798,  0.41072139],
       [ 1.98878445,  0.00424501,  1.6154884 , -0.29993039],
       [-1.15881282,  0.64665924,  0.85159943, -0.25057066],
       [ 0.58831105, -0.90918661, -0.55823388,  0.94581277]])

```

当然这里还有与(&)和或(|)来应对多个判断

```python
In [16]: mask = (names == "Bob") | (names=="J2")

In [17]: mask
Out[17]: array([ True, False,  True,  True, False, False, False])

In [18]: data[mask]
Out[18]: 
array([[-0.18325819, -0.66660485,  2.645787  ,  0.18188231],
       [ 0.70806562, -0.85558182,  1.57581798,  0.41072139],
       [-1.15387603,  0.65960428,  0.91796562,  0.61214259]])

```

通过布尔选值来进行元素的修改也是可行的

```python
In [20]: data
Out[20]: 
array([[0.        , 0.        , 2.645787  , 0.18188231],
       [0.62831675, 0.        , 0.        , 1.29473949],
       [0.70806562, 0.        , 1.57581798, 0.41072139],
       [0.        , 0.65960428, 0.91796562, 0.61214259],
       [1.98878445, 0.00424501, 1.6154884 , 0.        ],
       [0.        , 0.64665924, 0.85159943, 0.        ],
       [0.58831105, 0.        , 0.        , 0.94581277]])
#也可以利用一维数组来直接处理每一行的数据
In [21]: data[names=="J2"] = 7

In [22]: data
Out[22]: 
array([[0.00000000e+00, 0.00000000e+00, 2.64578700e+00, 1.81882310e-01],
       [6.28316746e-01, 0.00000000e+00, 0.00000000e+00, 1.29473949e+00],
       [7.00000000e+00, 7.00000000e+00, 7.00000000e+00, 7.00000000e+00],
       [0.00000000e+00, 6.59604282e-01, 9.17965615e-01, 6.12142587e-01],
       [1.98878445e+00, 4.24500620e-03, 1.61548840e+00, 0.00000000e+00],
       [0.00000000e+00, 6.46659239e-01, 8.51599430e-01, 0.00000000e+00],
       [5.88311053e-01, 0.00000000e+00, 0.00000000e+00, 9.45812766e-01]])

```

## 6. 神奇索引

使用整数数组进行索引

```python
In [23]: arr = np.empty((8,4))

In [24]: for i in range(8):
    ...:     arr[i]=i
    ...: 

In [25]: arr
Out[25]: 
array([[0., 0., 0., 0.],
       [1., 1., 1., 1.],
       [2., 2., 2., 2.],
       [3., 3., 3., 3.],
       [4., 4., 4., 4.],
       [5., 5., 5., 5.],
       [6., 6., 6., 6.],
       [7., 7., 7., 7.]])

```

为了选出一个复合顺序的子集，我们可以通过出单一个包含指明所需顺序的列表或者数组来完成

```python
In [26]: arr[[4,3,0,6]]
Out[26]: 
array([[4., 4., 4., 4.],
       [3., 3., 3., 3.],
       [0., 0., 0., 0.],
       [6., 6., 6., 6.]])

```

如果使用负索引，那么就是从尾部开始

```python
In [28]: arr[[-1,-3]]
Out[28]: 
array([[7., 7., 7., 7.],
       [5., 5., 5., 5.]])

```

如果传递多个索引数组的话，那么返回的将是选出的对应元素

```python
In [29]: arr =np.arange(16).reshape(4,4)

In [30]: arr
Out[30]: 
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15]])

In [31]: arr[[1,3,0],[2,1,0]]
Out[31]: array([ 6, 13,  0])
```

可以看到(1,2),(3,1),(0,0)被选中

以下例子我们先选出了对应的行，然后再选出对应的列。通过这样来完成之前应该出现的操作

```python
In [32]: arr[[1,3,0]][:,[2,1,0]]
Out[32]: 
array([[ 6,  5,  4],
       [14, 13, 12],
       [ 2,  1,  0]])

```

## 7.数组的转置和换轴

转置是一种特殊的操作，可以返回底层的视图而不需要任何内容，使用数组的`transpose`方法，也可以使用T属性

```python
In [33]: arr = np.arange(15).reshape((3,5))

In [34]: arr
Out[34]: 
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

In [35]: arr.T
Out[35]: 
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])

In [36]: arr.transpose()
Out[36]: 
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])

```

当我们进行内积的是会使用到`np.dot`方法，这时候我们使用转置就可以很好的进行计算

```python
In [37]: np.dot(arr.T,arr)
Out[37]: 
array([[125, 140, 155, 170, 185],
       [140, 158, 176, 194, 212],
       [155, 176, 197, 218, 239],
       [170, 194, 218, 242, 266],
       [185, 212, 239, 266, 293]])

```

对于更高维度的数组，transpose可以接收包含轴编号的元组，用来置换轴

```python
In [38]: arr = np.arange(16).reshape((2,2,4))

In [39]: arr
Out[39]: 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
In [42]: arr.transpose((1,2,0)).shape
Out[42]: (2, 4, 2)
In [43]: arr.transpose((1,2,0))
Out[43]: 
array([[[ 0,  8],
        [ 1,  9],
        [ 2, 10],
        [ 3, 11]],

       [[ 4, 12],
        [ 5, 13],
        [ 6, 14],
        [ 7, 15]]])


```

此时轴已经被重新排序，使得原本的第二个轴变为第一个，原本的第0个轴变为最后一个



使用`.T`进行转世的一个特殊案例：

ndarray有一个`swapaxes`方法，该方法接收一对轴编号作为参数，并对轴进行调整用于重组数据

```python
In [44]: arr
Out[44]: 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],

       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

In [45]: arr.swapaxes(1,2)
Out[45]: 
array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],

       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])
```

可以看到1，2两个轴进行了变换，`.T`其实就是交换了二维数组的0,1两个轴

同样`swapaxes`返回的也是一个视图！！！

